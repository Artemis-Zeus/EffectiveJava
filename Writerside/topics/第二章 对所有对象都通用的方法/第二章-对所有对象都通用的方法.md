 # 第二章-对所有对象都通用的方法

Java 中的 Object 类是所有类的超类，它定义了一些所有对象都通用的方法。正确地重写这些方法对于创建高质量的类至关重要。本章将介绍如何正确地重写这些方法，以及在什么情况下应该重写它们。

## 本章要点

本章包含以下关键条目：

1. [重写equals方法时遵守通用约定](覆盖equals时请遵守通用约定.md)
2. [重写equals方法时总是重写hashCode方法](重写equals方法时总是重写hashCode方法.md)
3. [总是重写toString方法](总是重写toString方法.md)
4. [谨慎重写clone方法](谨慎重写clone方法.md)
5. [考虑实现Comparable接口](考虑实现Comparable接口.md)

## 核心原则

在重写 Object 类的方法时，应遵循以下核心原则：

1. **遵守约定**：这些方法都有明确的通用约定，违反这些约定会导致不可预期的行为。
2. **一致性**：相关方法（如 equals 和 hashCode）必须保持一致。
3. **文档化**：清晰地文档说明你的实现行为，特别是当它与默认行为有所不同时。
4. **谨慎设计**：这些方法影响类的基本行为，需要仔细设计和测试。

## 最佳实践概览

### 1. equals 方法

- 只有在需要逻辑相等性而非对象同一性时才重写 equals
- 确保 equals 方法具有自反性、对称性、传递性和一致性
- 对于任何非 null 的引用值 x，x.equals(null) 必须返回 false
- 重写 equals 时必须重写 hashCode

### 2. hashCode 方法

- 相等的对象必须具有相等的哈希码
- 计算哈希码时应使用对象的关键字段
- 考虑缓存哈希码以提高性能
- 使用 Objects.hash 简化实现

### 3. toString 方法

- 提供一个信息丰富、易于阅读的表示形式
- 返回的字符串应包含对象的所有值得关注的信息
- 考虑指定 toString 返回值的格式并提供相应的解析方法

### 4. clone 方法

- 谨慎实现 Cloneable 接口
- 确保 clone 方法创建对象的深拷贝
- 考虑使用复制构造函数或复制工厂作为替代方案
- 处理好 final 字段和复杂对象图

### 5. Comparable 接口

- 为具有明显自然顺序的值类实现 Comparable
- 确保 compareTo 方法与 equals 一致
- 使用静态比较方法而非减法来避免整数溢出
- 考虑使用比较器构造方法（Java 8+）

## 常见问题

1. **equals 和 hashCode 不一致**：
   - 导致基于哈希的集合（如 HashMap、HashSet）无法正常工作
   - 对象可能无法在集合中被找到，即使它们"相等"

2. **不当的 clone 实现**：
   - 浅拷贝导致原对象和克隆对象共享可变状态
   - 未正确处理异常和类型转换

3. **compareTo 实现错误**：
   - 违反传递性导致排序不稳定
   - 使用减法导致整数溢出

4. **toString 信息不足**：
   - 调试困难
   - 日志信息不清晰

## 练习题

1. 为一个表示复数的类正确实现 equals 和 hashCode 方法。
2. 设计一个具有深拷贝功能的类，并实现 Cloneable 接口。
3. 为一个表示版本号的类（如 "1.2.3"）实现 Comparable 接口。
4. 实现一个具有信息丰富的 toString 方法，并提供解析该字符串的方法。

## 小结

本章介绍的方法虽然看似简单，但正确实现它们需要仔细考虑和设计。这些方法构成了类的基本行为，影响着类如何与 Java 平台的其余部分交互。遵循本章的最佳实践，可以创建行为一致、可靠且易于使用的类。

---

接下来，让我们详细了解每个具体的条目。